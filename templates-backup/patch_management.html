<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Patch Management | SDS - Autopatching Solution</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
  <style>
    body { background-color: #f8f9fa; }
    .table-wrap { background: #fff; border-radius: 8px; padding: 16px; margin-top: 20px; }
    .status-ok { color: green; font-weight: 600; }
    .status-fail { color: #d63333; font-weight: 600; }
    .status-patched { color: #0d6efd; font-weight: 600; }
    .status-pending { color: #6c757d; font-weight: 600; }
    .status-patching { color: orange; font-weight: 700; } /* new */
    .spinner-border-sm { width: 1rem; height: 1rem; }
  </style>
</head>

<body>

<!-- Clean and aligned Navbar -->
<nav class="navbar navbar-dark bg-dark p-2" style="border-bottom: 1px solid #444;">
  <div class="container-fluid d-flex flex-column align-items-start">
    
    <!-- Top Row: Sidebar Toggle + Title + Username -->
    <div class="d-flex w-100 justify-content-between align-items-center">
      <div class="d-flex align-items-center">
        <!-- Sidebar Toggle Button -->
        <button class="btn btn-dark me-2" type="button" data-bs-toggle="offcanvas" data-bs-target="#sidebarMenu" aria-controls="sidebarMenu">
          <span class="navbar-toggler-icon"></span>
        </button>

        <!-- App Title -->
        <div class="d-flex flex-column">
          <span class="navbar-brand mb-0 h5">SDS - Autopatching Solution</span>
          <small class="text-secondary">Patch Management</small>
        </div>
      </div>

      <!-- Username on right -->
      <div>
        {% if username %}
          <span class="navbar-text text-light small me-3">Signed in as {{ username }}</span>
        {% endif %}
      </div>
    </div>

    <!-- Second Row: Navigation Links -->
    <ul class="nav mt-2 ms-5">
      <li class="nav-item">
        <a class="nav-link text-white" href="{{ url_for('dashboard') }}">
          <i class="bi bi-house me-1"></i>Dashboard
        </a>
      </li>
      <li class="nav-item">
        <a class="nav-link text-white" href="{{ url_for('inventory') }}">
          <i class="bi bi-box-seam me-1"></i>Inventory
        </a>
      </li>
      <li class="nav-item">
        <a class="nav-link text-white" href="{{ url_for('packages') }}">
          <i class="bi bi-hdd-network me-1"></i>Patches
        </a>
      </li>
      <li class="nav-item">
        <a class="nav-link text-white" href="{{ url_for('log_history') }}">
          <i class="bi bi-clock-history me-1"></i>Log History
        </a>
      </li>
    </ul>
  </div>
</nav>

  <!-- Sidebar Menu -->
  <div class="offcanvas offcanvas-start bg-dark text-white" tabindex="-1" id="sidebarMenu">
    <div class="offcanvas-header border-bottom">
      <h5 class="offcanvas-title">Menu</h5>
      <button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas" aria-label="Close"></button>
    </div>
    <div class="offcanvas-body">
      <ul class="nav flex-column">
        <li class="nav-item mb-2">
          <a class="nav-link text-white" href="{{ url_for('dashboard') }}"><i class="bi bi-house me-2"></i>Dashboard</a>
        </li>
        <li class="nav-item mb-2">
          <a class="nav-link text-white" href="{{ url_for('inventory') }}"><i class="bi bi-box-seam me-2"></i>Inventory</a>
        </li>
        <li class="nav-item mb-2">
        <a class="nav-link text-white" href="{{ url_for('packages') }}"><i class="bi bi-hdd-network me-2"></i>Patches</a>
        </li>
        <li class="nav-item mb-2">
          <a class="nav-link text-white" href="{{ url_for('log_history') }}"><i class="bi bi-clock-history me-2"></i>Log History</a>
        </li>
        <li><hr class="text-secondary"></li>
        <li class="nav-item">
          <a class="nav-link text-danger" href="{{ url_for('logout') }}"><i class="bi bi-box-arrow-right me-2"></i>Logout</a>
        </li>
      </ul>
    </div>
  </div>

  <div class="container my-4">
    <h4>Patch Management</h4>
    <p class="text-muted">Select hosts from your <strong>current upload</strong> to perform further actions.</p>
    <div class="mb-3">
      <a class="btn btn-dark btn-sm" href="{{ url_for('patch_management_all') }}">Onboarded Servers</a>
    </div>

    {% if not hosts or hosts|length == 0 %}
      <div class="alert alert-warning">No hosts available. Please upload a file from the dashboard.</div>
    {% else %}
    <div class="card table-wrap">
      <div class="d-flex justify-content-between align-items-center mb-2">
        <div>
          <button id="selectAllBtn" class="btn btn-outline-secondary btn-sm">Select All</button>
        </div>
        <div class="d-flex gap-2">
          <button id="refreshStatusBtn" class="btn btn-outline-primary btn-sm">Refresh Status</button>
          <div id="refreshSpinner" class="spinner-border spinner-border-sm text-primary" style="display:none"></div>
          <button id="checkBtn" class="btn btn-success btn-sm">Connectivity Check</button>
          <div id="checkSpinner" class="spinner-border spinner-border-sm text-success" style="display:none"></div>
          <button id="precheckBtn" class="btn btn-success btn-sm">Run Pre-checks</button>
          <div id="precheckSpinner" class="spinner-border spinner-border-sm text-secondary" style="display:none"></div>
          <button id="patchBtn" class="btn btn-primary btn-sm" disabled>Trigger Patch</button>
          <div id="patchSpinner" class="spinner-border spinner-border-sm text-primary" style="display:none"></div>
          <button id="postcheckBtn" class="btn btn-success btn-sm">Run Post-checks</button>
          <div id="postcheckSpinner" class="spinner-border spinner-border-sm text-secondary" style="display:none"></div>
          <!-- <button id="rollbackBtn" class="btn btn-warning btn-sm" disabled>Rollback Changes</button>
          <div id="rollbackSpinner" class="spinner-border spinner-border-sm text-warning" style="display:none"></div> -->

        </div>
      </div>

      <div class="table-responsive">
        <table class="table table-striped table-sm" id="hostsTable">
          <thead>
            <tr>
              <th><input type="checkbox" id="selectAll"></th>
              <th>ID</th>
              <th>Host</th>
             
              <th>Status</th>
              <th>Message</th>
            </tr>
          </thead>
          <tbody>
            {% for h in hosts %}
              <tr data-id="{{ h.id }}">
                <td><input type="checkbox" class="hostCheck"></td>
                <td>{{ h.id }}</td>
                <td>{{ h.host }}</td>
                
                <td class="status {{ 'status-ok' if h.status=='success' else ('status-fail' if h.status=='failed' else 'status-pending') }}">
    {{ h.status }}
</td>
                <td class="message text-muted">{{ h.message or '' }}</td>
              </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>
    </div>
    {% endif %}
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    const checkBtn = document.getElementById("checkBtn");
    const patchBtn = document.getElementById("patchBtn");
    const precheckBtn = document.getElementById("precheckBtn");
    const postcheckBtn = document.getElementById("postcheckBtn");
    const selectAll = document.getElementById("selectAll");
    const selectAllBtn = document.getElementById("selectAllBtn");
    const checkSpinner = document.getElementById("checkSpinner");
    const patchSpinner = document.getElementById("patchSpinner");
    const hostCheckboxes = document.querySelectorAll(".hostCheck");
    const postcheckSpinner = document.getElementById("postcheckSpinner");
    const refreshStatusBtn = document.getElementById("refreshStatusBtn");
    const refreshSpinner = document.getElementById("refreshSpinner");

    // Select All functionality
    selectAll?.addEventListener("change", () => {
      hostCheckboxes.forEach(cb => cb.checked = selectAll.checked);
    });
    selectAllBtn?.addEventListener("click", () => {
      const allChecked = Array.from(hostCheckboxes).every(cb => cb.checked);
      hostCheckboxes.forEach(cb => cb.checked = !allChecked);
      selectAll.checked = !allChecked;
    });

    function getSelectedHosts() {
      return Array.from(document.querySelectorAll(".hostCheck"))
        .filter(cb => cb.checked)
        .map(cb => cb.closest("tr").dataset.id);
    }

    // --- Connectivity Check ---
    checkBtn?.addEventListener("click", async () => {
      const selected = getSelectedHosts();
      if (selected.length === 0) return alert("Select at least one host.");
      checkBtn.disabled = true; checkSpinner.style.display = "inline-block";
      // only manage patchBtn here; do not forcibly disable/enable other buttons
      try {
        const form = new FormData();
        for (const id of selected) form.append("host_ids[]", id);
        const resp = await fetch("{{ url_for('patch_check') }}", { method: "POST", body: form });
        const data = await resp.json();

        data.results.forEach(r => {
          const row = document.querySelector(`tr[data-id='${r.id}']`);
          if (row) {
            const statusTd = row.querySelector(".status");
            const msgTd = row.querySelector(".message");
            statusTd.textContent = r.ok ? "connected" : "failed";
            statusTd.className = r.ok ? "status status-ok" : "status status-fail";
            msgTd.textContent = r.msg;
          }
        });

        // enable patch if ANY selected host is connected
        const anyConnected = data.results.some(r => r.ok);
        patchBtn.disabled = !anyConnected;

        // Do NOT disable precheck/postcheck here; keep them available
        // precheckBtn.disabled = !anyConnected;
        // postcheckBtn.disabled = !anyConnected;

      } catch (err) {
        console.error("Error:", err);
        alert("Connectivity check failed.");
      } finally {
        checkBtn.disabled = false; checkSpinner.style.display = "none";
      }
    });

    // --- Trigger Patch ---
    patchBtn?.addEventListener("click", async () => {
      const selected = getSelectedHosts();
      if (selected.length === 0) return alert("Select hosts to patch.");

      // Inspect current status values in the table and split connected/failed
      const connectedIds = [];
      const failedIds = [];
      selected.forEach(id => {
        const row = document.querySelector(`tr[data-id='${id}']`);
        if (!row) return;
        const statusText = (row.querySelector(".status").textContent || "").toLowerCase();
        if (statusText.includes("connected") || statusText.includes("pre-checked") || statusText.includes("patched") || statusText.includes("success")) {
          connectedIds.push(id);
        } else {
          failedIds.push(id);
        }
      });

      if (connectedIds.length === 0) {
        // none connected -> notify and abort
        return alert("None of the selected hosts have a passing connectivity check. Patch will not be triggered.");
      }

      // Build the informative message listing failed hosts (if any)
      let message = "";
      if (failedIds.length) {
        const failedList = failedIds.map(id => {
          const row = document.querySelector(`tr[data-id='${id}']`);
          const host = row ? row.querySelectorAll("td")[2].textContent : id;
          const msg = row ? (row.querySelector(".message").textContent || "").trim() : "";
          return `- ${host} (id ${id}) : ${msg || "connectivity failed"}`;
        }).join("\n");
        message += `The following selected hosts failed the connectivity check and will NOT be patched:\n\n${failedList}\n\n`;
      }
      message += `Proceed to patch the remaining ${connectedIds.length} host(s)? (OK to proceed)`;

      if (!confirm(message)) return;

      // proceed: send only connectedIds to server
      patchBtn.disabled = true;
      patchSpinner.style.display = "inline-block";

      try {
        const form = new FormData();
        for (const id of connectedIds) form.append("host_ids[]", id);

        const resp = await fetch("{{ url_for('trigger_patch') }}", { method: "POST", body: form });

        // Debug logging (keeps helpful info in console)
        console.log("[PATCH] HTTP status:", resp.status, "ok:", resp.ok);
        try {
          const text = await resp.clone().text().catch(() => "<no body>");
          console.log("[PATCH] Response body (trimmed):", text.slice(0, 2000));
        } catch (e) {
          console.warn("[PATCH] Couldn't read response body:", e);
        }

        // If server accepted job to run in background
        if (resp.status === 202) {
          // optimistic UI: set all connected rows to 'patching'
          connectedIds.forEach(id => {
            const row = document.querySelector(`tr[data-id='${id}']`);
            if (!row) return;
            const statusTd = row.querySelector(".status");
            statusTd.textContent = "patching";
            statusTd.className = "status status-patching";
            const msgTd = row.querySelector(".message");
            msgTd.textContent = "Patch job accepted — patching in progress";
          });

          // For failed hosts, leave status/message as-is (so users see they didn't get patched)
          alert("Patch job accepted — running in background for successful hosts. Refresh the page after a few minutes to see final status.");
          return;
        }

        // Non-202: if server returned JSON results (synchronous)
        if (resp.ok) {
          const contentType = resp.headers.get("content-type") || "";
          if (contentType.includes("application/json")) {
            const data = await resp.json().catch(() => null);
            if (data && data.results && Array.isArray(data.results)) {
              // Update UI from server-provided results (finalized)
              data.results.forEach(r => {
                const row = document.querySelector(`tr[data-id='${r.id}']`);
                if (!row) return;
                const statusTd = row.querySelector(".status");
                const msgTd = row.querySelector(".message");
                // server says ok => patched else failed
                statusTd.textContent = r.ok ? "patched" : "patch_failed";
                statusTd.className = r.ok ? "status status-patch-success" : "status status-patch-failed";
                msgTd.textContent = r.msg || (r.ok ? "patched" : "failed");
              });
              alert("Patch completed for selected hosts (see table).");
              return;
            } else {
              // JSON but unexpected shape: fallback to optimistic UI
              console.warn("[PATCH] JSON response unexpected shape, using optimistic UI.");
            }
          } else {
            // non-json 2xx response — optimistic UI
            console.warn("[PATCH] 2xx non-json response, using optimistic UI.");
          }
        }

        // If we reach here, treat as server error or unexpected response
        alert("Patch trigger returned unexpected response (status " + resp.status + "). Check server logs and network tab.");
      } catch (err) {
        console.error("[PATCH] Network/JS error:", err);
        alert("Patch trigger failed (network error). Check console and server logs.");
      } finally {
        patchBtn.disabled = false;
        patchSpinner.style.display = "none";
      }
    });


    precheckBtn?.addEventListener("click", async () => {
      const selected = getSelectedHosts();
      if (selected.length === 0) return alert("Select at least one host.");

      precheckBtn.disabled = true;
      precheckSpinner.style.display = "inline-block";

      try {
        const form = new FormData();
        for (const id of selected) form.append("host_ids[]", id);
        form.append("kind", "pre");

        const resp = await fetch("{{ url_for('run_checks') }}", { method: "POST", body: form });
        const data = await resp.json();

        data.results.forEach(r => {
          const row = document.querySelector(`tr[data-id='${r.id}']`);
          if (row) {
            const statusTd = row.querySelector(".status");
            const msgTd = row.querySelector(".message");
            if (r.ok) {
              // show prechecked
              statusTd.textContent = "pre-checked";
              statusTd.className = "status status-ok";
              msgTd.textContent = "Pre-check OK";
            } else {
              statusTd.textContent = "failed";
              statusTd.className = "status status-fail";
              msgTd.textContent = r.msg || "Pre-check failed";
            }
          }
        });

        alert("Pre-check(s) completed. Use Post-check after patching.");
      } catch (err) {
        console.error("Precheck error:", err);
        alert("Pre-check failed.");
      } finally {
        precheckBtn.disabled = false;
        precheckSpinner.style.display = "none";
      }
    });


    postcheckBtn?.addEventListener("click", async () => {
      const selected = getSelectedHosts();
      if (selected.length === 0) return alert("Select at least one host.");
      // ensure selected hosts are patched
      // Allow postcheck only for hosts whose status indicates success/patch completed
      const notPatched = selected.filter(id => {
        const row = document.querySelector(`tr[data-id='${id}']`);
        const statusText = (row?.querySelector(".status")?.textContent || "").toLowerCase();
        // treat any text containing 'success' or 'patch' as a completed/ok state
        const isPatchedOrSuccess = statusText.includes("success") || statusText.includes("patch");
        return row && !isPatchedOrSuccess;
      });
      if (notPatched.length) {
        // show a helpful message listing offending hosts (optional)
        const badHosts = notPatched.map(id => {
          const r = document.querySelector(`tr[data-id='${id}']`);
          return r ? r.querySelectorAll("td")[2].textContent.trim() + ` (id ${id})` : id;
        }).join(", ");
        return alert("Post-check allowed only for hosts with status 'success' or 'patched'. Problem with: " + badHosts);
      }

      postcheckBtn.disabled = true;
      postcheckSpinner.style.display = "inline-block";

      try {
        const form = new FormData();
        for (const id of selected) form.append("host_ids[]", id);
        form.append("kind", "post");

        const resp = await fetch("{{ url_for('run_checks') }}", { method: "POST", body: form });
        const data = await resp.json();

        // For each host, show simple diff summary (green if ok, red if changes)
        data.results.forEach(r => {
          const row = document.querySelector(`tr[data-id='${r.id}']`);
          if (!row) return;
          const statusTd = row.querySelector(".status");
          const msgTd = row.querySelector(".message");
          if (r.diff) {
            if (r.diff.ok === true) {
              // no changes found
              msgTd.textContent = "Post-check OK (no important changes)";
              statusTd.textContent = "patched";
              statusTd.className = "status status-patched";
            } else if (r.diff.changes && r.diff.changes.length) {
              // highlight changes
              msgTd.textContent = "Post-check: changes -> " + r.diff.changes.map(c => c.field).join(", ");
              statusTd.textContent = "postcheck: issues";
              statusTd.className = "status status-fail";
            } else if (r.diff.warning) {
              msgTd.textContent = "Post-check: " + r.diff.warning;
            } else if (r.diff.error) {
              msgTd.textContent = "Post-check error";
              statusTd.textContent = "failed";
              statusTd.className = "status status-fail";
            }
          } else if (!r.ok) {
            msgTd.textContent = r.msg || "Post-check failed";
            statusTd.textContent = "failed";
            statusTd.className = "status status-fail";
          }
        });

        alert("Post-check(s) completed. See messages for quick diff summary.");
      } catch (err) {
        console.error("Postcheck error:", err);
        alert("Post-check failed.");
      } finally {
        postcheckBtn.disabled = false;
        postcheckSpinner.style.display = "none";
      }
    });

    async function refreshTableStatus() {
      refreshStatusBtn.disabled = true;
      refreshSpinner.style.display = "inline-block";
      try {
        // fetch current page HTML (same URL). Using cache: 'no-store' ensures fresh server response.
        const resp = await fetch(window.location.href, { cache: 'no-store' });
        if (!resp.ok) throw new Error("Failed to fetch page: " + resp.status);
        const html = await resp.text();

        // parse returned HTML and extract the new tbody
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");
        const newTbody = doc.querySelector("#hostsTable tbody");
        const oldTbody = document.querySelector("#hostsTable tbody");

        if (newTbody && oldTbody) {
          // Replace only the rows (preserves event listeners on buttons outside)
          oldTbody.innerHTML = newTbody.innerHTML;

          // Re-wire any JS state that depends on DOM elements like hostCheckboxes variable:
          // (re-query host checkboxes and selectAll behaviour)
          rebindHostCheckboxes();
        } else {
          console.warn("Couldn't find table tbody in fetched HTML. Falling back to full reload.");
          // fallback to full reload if structure changed unexpectedly
          window.location.reload();
        }
      } catch (err) {
        console.error("refreshTableStatus error:", err);
        alert("Could not refresh status. See console for details.");
      } finally {
        refreshStatusBtn.disabled = false;
        refreshSpinner.style.display = "none";
      }
    }

    refreshStatusBtn?.addEventListener("click", refreshTableStatus);

    // helper to rebind checkbox NodeList and select-all after tbody replacement:
    function rebindHostCheckboxes() {
      // re-query checkboxes
      const newCheckboxes = document.querySelectorAll(".hostCheck");
      // update global-ish reference if you use it elsewhere
      // (we previously had hostCheckboxes const - it's a static NodeList; replace it if needed)
      // If other parts of your code use the hostCheckboxes variable, reassign it:
      // hostCheckboxes = newCheckboxes; // if hostCheckboxes declared with let or var
      // But in current code hostCheckboxes was a const, so rebind select-all listeners manually:

      // ensure selectAll checkbox state is correct
      const selectAllCb = document.getElementById("selectAll");
      if (selectAllCb) {
        selectAllCb.checked = Array.from(newCheckboxes).every(cb => cb.checked);
      }

      // attach change handler to new checkboxes if your code relied on it
      newCheckboxes.forEach(cb => {
        cb.addEventListener("change", () => {
          const allChecked = Array.from(document.querySelectorAll(".hostCheck")).every(c => c.checked);
          if (selectAllCb) selectAllCb.checked = allChecked;
        });
      });
    }
  </script>
</body>
</html>